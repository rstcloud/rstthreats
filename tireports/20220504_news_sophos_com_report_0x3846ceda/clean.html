<div>
<img alt="" class="object-cover wp-post-image" height="680" src="https://news.sophos.com/wp-content/uploads/2022/04/shutterstock_105181163.jpg?w=1000" style="max-width:800px;height:auto;width:auto;" width="1000"/>
<img alt="SophosLabs Uncut" src="https://news.sophos.com/wp-content/uploads/2021/05/Category-Icon-Threat-Research@2x.min_.png" style="max-width:80%;height:auto;width:auto;"/>
<h1 class="text-style-h1 mb-8">Attacking Emotet’s Control Flow Flattening</h1>
						Sweeping aside one obfuscation technique in a notorious strain of malware					
		Written by 				
<a class="author url fn" href="https://news.sophos.com/en-us/author/andreas-klopsch/" rel="author" title="Posts by Andreas Klopsch">Andreas Klopsch</a>
<a href="https://news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening/" rel="bookmark">May 04, 2022</a>
<a class="category-tag-pill" href="https://news.sophos.com/en-us/category/threat-research/sophoslabs-uncut/">SophosLabs Uncut</a> <a class="category-tag-pill" href="https://news.sophos.com/en-us/tag/emotet/">emotet</a> <a class="category-tag-pill" href="https://news.sophos.com/en-us/tag/obfuscation/">obfuscation</a> <a class="category-tag-pill" href="https://news.sophos.com/en-us/tag/secops/">SecOps</a>
<p>Emotet has been one of the most professional and long-lasting cybercrime services and malware infections in the threat landscape. Notorious since shortly after its debut in 2014, the botnet was disrupted in January 2021 by a multinational law enforcement effort that sidelined its activity for almost a year. Unfortunately, in November 2021 the botnet re-emerged and once again began to appear on Sophos’ radar.</p>
<p>To protect our customers, SophosLabs is always looking for the most significant techniques, tactics, and procedures used to distribute and deliver Emotet. In this post, we’ll look at Control Flow Flattening (CFF), one of several obfuscation tactics Emotet’s developers use to make detection and reverse engineering of the malware’s payload more difficult. We’ll provide a brief example of CFF applied to a simple hello-world program, and then discuss how Sophos researchers address CFF in Emotet’s code. We’ll finish by summarizing the challenges and problems we encountered during research.</p>
<p>Emotet’s internals have been covered by many researchers, but we have not seen discussions on de-obfuscating its use of Control Flow Flattening so far.</p>
<p>Emotet: Resurgence and Tenacity </p>
<p>Figure 1 shows the volume of Emotet payloads detected in our sandbox systems in the first quarter of 2022. As the chart shows, we receive multiple Emotet submissions daily; we believe that the recurring larger spikes result from large-scale campaigns being kicked off by the malware’s distributors. This is a sensible assumption; Emotet is mainly distributed via email spam, and more malicious emails naturally lead to more sandbox submissions. </p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/PIcture1-1a.png"><img alt="Timeline showing Emotet sandbox trends during the first quarter of 2022" class="alignnone size-full wp-image-84355" height="239" src="https://news.sophos.com/wp-content/uploads/2022/04/PIcture1-1a.png" width="640"/></a></p>
<p>Figure 1: Timeline of 2022 Emotet detections in SophosLabs’ sandbox systems </p>
<p>In addition to Emotet’s delivery mechanism and prevalence, we also analyze the final payload in depth. Thus, we noticed Control Flow Flattening in an unpacked Emotet sample. Control Flow Flattening hides program flow by putting all function blocks next to each other. It is a well-known obfuscation technique used to conceal the purpose of software. While extracting the original code from a flattened binary is inherently challenging, we have successfully adapted some existing toolsets to deobfuscate the majority of Emotet payload functionality. </p>
<p>What is Control Flow Flattening?</p>
<p>Control Flow Flattening is a technique that aims to obfuscate program flow by taking away tidy program structures in favor of putting the program blocks inside a loop with a single switch statement controlling program flow.</p>
<p>First, the body of the function is broken into basic blocks, and then the blocks are put next to each other on the same level. A visualization of this transformation can be seen in Figure 2. Control Flow Flattening can be combined with other obfuscation techniques, such as API Hashing or String Encryption. Some of the most prominent obfuscators for flattening functions are <a href="https://github.com/obfuscator-llvm/obfuscator/wiki">OLLVM</a> and <a href="http://tigress.cs.arizona.edu/">Tigress</a>.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture2-1.png"><img alt="Comparing a flattened and non-flattened control flow graph (CFG)" class="alignnone size-full wp-image-84224" height="305" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture2-1.png" width="606"/></a></p>
<p>Figure 2: Comparing a flattened and non-flattened control flow graph (CFG)</p>
<p>Let’s take a quick look at a simplified example of CFF in action.</p>
<p>Flattening Hello World</p>
<p>For demonstration purposes, we’ve compiled a simple program written in C. On the left side of Figure 3, an annotated control flow graph (CFG) of the binary is shown. On the right side you can see the decompiled output generated by the Hex-Rays Decompiler.</p>
<p>In this figure, no obfuscation techniques have been applied. The Hex-Rays Decompiler has no trouble generating an easy-to-read high-level language representation of the disassembly. Even without a decompiler, an experienced reverse engineer can simply follow the control flow graph to understand its purpose.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture3-1.png"><img alt="Control Flow Graph and decompiled output of sample program" class="alignnone size-full wp-image-84225" height="315" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture3-1.png" width="602"/></a></p>
<p>Figure 3: Control Flow Graph and decompiled output of sample program</p>
<p>Now we’ll flatten the function and compare the results. Figure 4 displays the CFG and decompiled output after Control Flow Flattening was applied. On the left side, we see that the number of basic blocks has more than doubled, and reading the decompiled output is not possible any more without spending a significant amount of time analyzing it.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture4-1.png"><img alt="Annotated example of a flattened function" class="alignnone size-full wp-image-84227" height="245" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture4-1.png" width="640"/></a></p>
<p>Figure 4: Annotated example of a flattened function</p>
<p>Overall, CFF introduces the following problems to hamper our analysis:</p>
<ul>
<li>The control flow is concealed. Instead of being able to follow the blocks, a control flow dispatcher block is implemented. This block determines which blocks are executed next.</li>
<li>A state variable annotated as <code>stateVar </code>in the decompiled output is updated with high entropy variables throughout the function. The state variable is used by the control flow dispatcher to decide which block gets executed next.</li>
<li>The two problems above lead to a highly complex decompiled output. While it is still possible to follow the execution flow, the time and effort needed to understand the function is significantly larger than it would be compared to the decompiled output in Figure 3.</li>
</ul>
<p>Unflattening Emotet</p>
<p>To deobfuscate Emotet’s use of Control Flow Flattening, we started with a review of existing tools and research on CFG deobfuscation. Some of those include:</p>
<ul>
<li><a href="https://hex-rays.com/blog/hex-rays-microcode-api-vs-obfuscating-compiler/">Hex-Rays Microcode API vs. Obfuscating Compiler</a> by Rolf Rolles</li>
<li><a href="https://blogs.vmware.com/security/2019/02/defeating-compiler-level-obfuscations-used-in-apt10-malware.html">Defeating Compiler-Level Obfuscations used in APT10 Malware</a> by VMWare’s Threat Analysis Unit</li>
<li><a href="https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">Deobfuscation: recovering an OLLVM-protected program</a> by Francis Gabriel of Quarkslab</li>
<li><a href="https://eshard.com/posts/D810-a-journey-into-control-flow-unflattening">D810: A journey into control flow unflattening</a> by Boris Batteaux of eShard</li>
</ul>
<p>For deeper dives into the algorithm behind CFG Unflattening, the articles referenced above provide a wealth of information.</p>
<p>In Figure 5 you can see the decompiled output and CFG of a function in an unpacked Emotet sample. Excluding the Control Flow Flattening applied here, the output might seem confusing, because Emotet applies more than just one obfuscation technique. (If you are not familiar with those other techniques, an appendix at the end of this article briefly explains the other obfuscation techniques .)</p>
<p>First, the function calls OpenSCManagerA to retrieve a handle to the Service Control Manager. Next, it calls OpenServiceW to open an existing service. If opening the service succeeds, the opened service will be deleted via DeleteService. Finally, the opened handles will be closed. If the service was deleted successfully, the function returns 1, otherwise 0.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture5-1.png"><img alt="Annotated example of a flattened function" class="alignnone size-full wp-image-84228" height="300" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture5-1.png" width="640"/></a></p>
<p>Figure 5: Annotated example of a flattened function</p>
<p>If we compare the decompiled output of Figure 3 and Figure 4, we can see multiple similarities, and we can identify the CFG dispatcher again. In the decompiled output, we see a variable we annotated as <code>stateVar</code>. Like the output in Figure 3, this is our state variable that is constantly updated and used by the dispatcher to determine which block is executed next.</p>
<p>On a high level, if we want to restore the control flow, we need to:</p>
<ol>
<li>Identify the dispatcher block and states</li>
<li>For each block, identify the corresponding constant and find the address of the next block to execute based on dispatcher and state variable value</li>
<li>Patch the outbound dispatcher blocks to jump to the address of the original next block</li>
</ol>
<p>Instead of patching and operating on the disassembly directly, we make use of the Hex-Rays Microcode API. Microcode is an intermediate language used by the Hex-Rays decompiler. During decompilation, the decompiler steps through different maturity phases. The different phases are displayed in Figure 6 below. The API allows us to hook the decompilation progress and operate on the microcode instead of patching the disassembly directly.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture6.png"><img alt="IDA Microcode maturity levels" class="alignnone size-full wp-image-84229" height="363" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture6.png" width="601"/></a></p>
<p>Figure 6: IDA Microcode maturity levels</p>
<p>Adjusting the Tool</p>
<p>We used an IDAPython fork of the Rolf Rolles’ HexRaysDeob tool as our foundation. Like the fork, we are operating solely on the maturity level MMAT_LOCOPT, the third level in the figure above. As seen in Figure 6, that maturity level includes information about inbound and outbound blocks, which are necessary to correctly identify dispatcher blocks. Furthermore, the original code was based around the MMAT_LOCOPT layer. Changing the layer would have required plenty more investigation, verification, and adjustments of the existing code than keeping the layer. Below is a summarization of changes we applied on the existing code base.</p>
<p>Handling Multiple/Related Dispatchers</p>
<p>In multiple functions, running the deobfuscation algorithm on a single dispatcher did not generate an output we were satisfied with. Analysis showed that more complex functions might contain multiple nested dispatchers instead of one. We added additional logic to identify and run the algorithm on multiple dispatchers. This option can be turned on or off by setting the RUN_MLTPL_DISPATCHERS flag to True or False. In Figure 7 below, you can see an example of a function with two potential dispatchers.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture7.png"><img alt="Example of a function of two potential dispatchers" class="alignnone size-full wp-image-84231" height="406" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture7.png" width="598"/></a></p>
<p>Figure 7: Example of a function with two potential dispatchers</p>
<p>Risky Search for the Cluster Head </p>
<p>A flattened block might be implemented by multiple microcode blocks. To find the end of the region, the original algorithm by Rolf Rolles generates a dominator tree and uses the generated information to determine the end of a region, or the beginning of a cluster. In some cases, the algorithm failed to find the cluster head. We added an additional function to determine the cluster head as a fallback. We believe that the original algorithm by Rolf Rolles is more reliable; however, evaluation showed that the fallback algorithm still led to good results and improved the decompiled output.</p>
<p>Adding Additional Patterns and Small Code Updates</p>
<p>In some cases, the existing logic failed in patching all flattened blocks. After analyzing multiple functions, we identified various patterns that reoccurred throughout the whole binary. We added additional logic to identify and unflatten blocks following these patterns to the existing code base. Finally, we adjusted the overall code a little. Some of the changes include:</p>
<ul>
<li>The IDAPython fork of Rolf Rolles´ HexRaysDeob tool was based on Python2.7. We updated several parts of the code to match Python3 standards.</li>
<li>In the original version of the tool, if the “run” function was invoked once, the plugin got activated and if the tool determined the function as flattened via an algorithm, it attempted to unflatten it. During implementation and testing, we experienced crashes of IDA Pro when using the IDAPython microcode API. This might lead to a corrupted IDB database. As an additional safety mechanism, the address of the target function must be added to the array “white_list” to allow unflattening. Overall, we recommend saving often and keeping a separate IDB copy when using the tool.</li>
</ul>
<p>Out of 254 functions, we categorized 68 functions as flattened. From these 68 functions, we were able to unflatten 38 successfully. Nineteen functions were partially flattened, and 11 functions failed. By “unflattened successfully,” we mean cases in which our script failed to unflatten a maximum of 3 states. “Partially unflattened” means that most of the function remains flattened, but our tool was able to unflatten some blocks. Finally, “failed” means that we were not able to deobfuscate a single block in the function.</p>
<p>Figure 8 below shows the function from Figure 5 after our script was applied.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture8.png"><img alt="Analyzed function after the CFG unflattening tool was applied" class="alignnone size-full wp-image-84232" height="404" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture8.png" width="640"/></a></p>
<p>Figure 8: Analyzed function after the CFG unflattening tool was applied</p>
<p>IoCs</p>
<table>
<tbody>
<tr>
<td width="301">
<p>Description</p>
</td>
<td width="301">
<p>SHA256</p>
</td>
</tr>
<tr>
<td width="301">
<p>Packed Emotet</p>
</td>
<td width="301">
<p>9a0286ec0a3e7ea346759c9497c8b5c7c212fa2c780a1cabb094134bf492a51b</p>
</td>
</tr>
<tr>
<td width="301">
<p>Unpacked Emotet</p>
</td>
<td width="301">
<p>1bbce395c839c737fdc983534b963a1521ab9693a5b585f15b8a4950adea5973</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Our unflattening tool is <a href="https://github.com/sophoslabs/emotet_unflatten_poc">now available</a> on the SophosLabs Github. (For those interested in such things, we also recommend to your attention a <a class="Hyperlink SCXW235147564 BCX0" href="https://github.com/eset/stadeo" rel="noreferrer noopener" target="_blank">CFF-unpacking tool</a> released by ESET several years back to address control-flow flattening in the Stantinko botnet – another example of why, since attackers freely share tactics, techniques, and procedures among themselves, defenders are wise to do the same.)</p>
<p>Conclusion and Limitations</p>
<p>Control Flow Flattening is a complex topic, and the purpose of this article is to share our experience and results attacking Emotet’s Control Flow Flattening. While we made multiple adjustments and met with some success, our solution is not able to deobfuscate all functions completely. Among the outstanding issues:</p>
<ul>
<li>The algorithm to detect nested dispatchers is simple. Therefore, we have added an option to turn it on and off. In rare cases, a faulty output is generated if the nested dispatcher is enabled.</li>
<li>In many functions, we had to deal with conditional states. Depending on the outcome of, for example, a WINAPI function, the state variable changes to a different value at runtime. Additional patching and insertion of microcode instructions would be needed to unflatten these conditional blocks.</li>
<li>Our main approach was to add logic for reoccurring patterns in the binary. As our work progressed, we realized that a microcode emulator might have been a better choice, or would have been an adjustment that led to more unflattened blocks.</li>
<li>During development and evaluation, we experienced multiple crashes. We are all humans and we make mistakes, so some crashes will result from bugs in our code. However, judging from the error messages, we believe that there is a deeper-rooted problem in the Python port of the Microcode API. Therefore, we recommend saving often and keeping a copy of the IDB file.</li>
</ul>
<p>Overall, we recommend that researchers always cross-check their results and not trust the output blindly. Control Flow Flattening used in conjunction with other obfuscation techniques certainly complicates the process of reverse engineering Emotet, but the technique we’ve described helps to even the odds against researchers examining this high-profile malware.</p>
<h2>Appendix: Emotet and Code Obfuscation</h2>
<p>When sharing the decompiled output of functions in an Emotet sample, it is impossible not to encounter other Emotet obfuscation techniques beyond CFF. This appendix covers the most prevalent obfuscation techniques we have identified in an unpacked Emotet sample. Keep in mind that Emotet is usually delivered in a packed form and needs to be unpacked first.</p>
<p>String Encryption</p>
<p>Emotet contains encrypted strings in its unpacked form. Before usage, strings will be decrypted and freed again right after each serves its purpose.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture9.png"><img alt="Cross references of DecryptString function with corresponding decrypted string" class="alignnone size-full wp-image-84233" height="156" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture9.png" width="632"/></a></p>
<p>Figure 9: Cross references of DecryptString function with corresponding decrypted string</p>
<p>API Hashing</p>
<p>Emotet uses API Hashing to conceal the usage of API functions. The malware calculates the hash of exported function names for a given DLL. If the calculated hash matches the constant pushed onto the stack at method invocation, the pointer to the exported function will be retrieved.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture10.png"><img alt="Disassembly of ApiHash function invocation" class="alignnone size-full wp-image-84235" height="314" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture10.png" width="503"/></a></p>
<p>Figure 10: Disassembly of ApiHash function invocation</p>
<p>In most cases, API Hashing calls and their corresponding dynamic call are wrapped into separate functions. We have automated this analysis, and functions with prefix DYN_ are functions determined at runtime via API Hashing.</p>
<p>Junk Instructions</p>
<p>Emotet embeds junk instructions to confuse reverse engineers. Junk instructions are instructions that do not serve any purpose except to complicate and slow down analysis. Figure 11 below shows an example of a junk instruction block.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture11.png"><img alt="Example of junk instructions in unpacked Emotet sample" class="alignnone size-full wp-image-84236" height="292" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture11.png" width="410"/></a></p>
<p>Figure 11: Example of junk instructions in unpacked Emotet sample</p>
<p>Stack Obfuscation</p>
<p>Another interesting technique that confuses the IDA decompiler is the way in which Emotet passes parameters to functions. In Figure 12 below, we show how DYN_BCryptEncrypt is invoked.</p>
<p>DYN_BCryptEncrypt first resolves the API function BCryptEncrypt and stores the pointer to this function in register EAX. The function is then called via call EAX. Instead of just pushing the necessary parameters, this method pushes values onto the stack not being used by the actual EAX call. This leads to generation of a function signature that is much harder to read than normal.</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture12.png"><img alt="Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked" class="alignnone size-full wp-image-84237" height="255" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture12.png" width="640"/></a></p>
<p>Figure 12: Multiple values being pushed onto the stack before DYN_BCryptEncrypt is invoked</p>
<p><a href="https://news.sophos.com/wp-content/uploads/2022/04/Picture13.png"><img alt="Corresponding generated function signature" class="alignnone size-full wp-image-84238" height="212" src="https://news.sophos.com/wp-content/uploads/2022/04/Picture13.png" width="640"/></a></p>
<p>Figure 13: Corresponding generated function signature</p>
<p> </p>
<ul class="flex justify-center items-center space-x-6" id="social-sharing">
<li class="facebook">
<a class="js-share-modal" href="http://www.facebook.com/share.php?u=https://news.sophos.com/?p=84215&amp;title=Attacking%20Emotet%E2%80%99s%20Control%20Flow%20Flattening" title="Share on Facebook">
Share on Facebook
</a>
</li>
<li class="twitter">
<a class="js-share-modal" href="http://twitter.com/intent/tweet?text=Attacking%20Emotet%E2%80%99s%20Control%20Flow%20Flattening%20https%3A%2F%2Fnews.sophos.com%2F%3Fp%3D84215" title="Share on Twitter">
Share on Twitter
</a>
</li>
<li class="linkedin">
<a href="http://www.linkedin.com/shareArticle?mini=true&amp;url=https://news.sophos.com/en-us/2022/05/04/attacking-emotets-control-flow-flattening/" title="Share on LinkedIn">
Share on LinkedIn
</a>
</li>
<li class="comments">
<a class="flex items-center space-x-1" href="#comments" title="Leave a Reply">
</a>
</li>
</ul>
</div>